#!/usr/bin/env node

/**
 * Script to analyze current Next.js file structure and plan the restructuring
 * needed for TanStack Start file naming conventions
 *
 * Usage: node scripts/plan-file-restructure.js
 */

import { readFileSync, readdirSync, statSync } from "fs";
import { basename, dirname, extname, join } from "path";

const ROUTES_DIR = "apps/web/src/app";

function getAllRouteFiles(dir, files = [], relativePath = "") {
  try {
    const entries = readdirSync(dir);

    for (const entry of entries) {
      const fullPath = join(dir, entry);
      const relativeEntryPath = relativePath
        ? join(relativePath, entry)
        : entry;
      const stat = statSync(fullPath);

      if (stat.isDirectory()) {
        getAllRouteFiles(fullPath, files, relativeEntryPath);
      } else if (extname(entry) === ".tsx" && !entry.startsWith("-")) {
        files.push({
          fullPath,
          relativePath: relativeEntryPath,
          dir: relativePath,
          name: entry,
          type: getFileType(entry, relativePath),
        });
      }
    }
  } catch (error) {
    console.error(`Error reading directory ${dir}:`, error.message);
  }

  return files;
}

function getFileType(filename, dirPath) {
  if (filename === "__root.tsx") return "root";
  if (filename === "page.tsx") return "page";
  if (filename === "layout.tsx") return "layout";
  if (filename === "loading.tsx") return "loading";
  if (filename === "error.tsx") return "error";
  if (filename === "not-found.tsx") return "not-found";
  if (filename === "route.tsx") return "route";
  if (filename.includes(".")) return "component";
  return "other";
}

function isDynamicRoute(pathSegment) {
  return pathSegment.startsWith("[") && pathSegment.endsWith("]");
}

function isRouteGroup(pathSegment) {
  return pathSegment.startsWith("(") && pathSegment.endsWith(")");
}

function convertToTanStackPath(nextjsPath) {
  const segments = nextjsPath.split("/").filter(Boolean);
  const convertedSegments = segments.map((segment) => {
    if (isDynamicRoute(segment)) {
      // [bottleId] -> $bottleId
      return `$${segment.slice(1, -1)}`;
    }
    if (isRouteGroup(segment)) {
      // (default) -> (default)
      return segment;
    }
    return segment;
  });

  return convertedSegments.join(".");
}

function analyzeDynamicRoutes(files) {
  const dynamicRoutes = [];

  files.forEach((file) => {
    const pathSegments = file.dir.split("/").filter(Boolean);
    const hasDynamicSegments = pathSegments.some(isDynamicRoute);

    if (hasDynamicSegments) {
      const originalPath = file.dir;
      const newPath = convertToTanStackPath(originalPath);
      const newFileName = newPath ? `${newPath}.tsx` : file.name;

      dynamicRoutes.push({
        original: file,
        suggested: {
          oldPath: file.relativePath,
          newPath: newFileName,
          oldDir: file.dir,
          newDir: "", // Flat structure
          conversionType: "dynamic-route",
        },
      });
    }
  });

  return dynamicRoutes;
}

function analyzeLayoutPagePairs(files) {
  const pairs = [];
  const layoutFiles = files.filter((f) => f.type === "layout");
  const pageFiles = files.filter((f) => f.type === "page");

  layoutFiles.forEach((layout) => {
    const matchingPage = pageFiles.find((page) => page.dir === layout.dir);
    if (matchingPage) {
      const routePath = convertToTanStackPath(layout.dir);
      const newFileName = routePath ? `${routePath}.tsx` : "index.tsx";

      pairs.push({
        layout: layout,
        page: matchingPage,
        suggested: {
          oldLayoutPath: layout.relativePath,
          oldPagePath: matchingPage.relativePath,
          newPath: newFileName,
          conversionType: "layout-page-merge",
        },
      });
    }
  });

  return pairs;
}

function analyzeNestedRoutes(files) {
  const nested = [];

  files.forEach((file) => {
    if (file.dir && file.dir.includes("/")) {
      const depth = file.dir.split("/").length;
      if (depth > 2) {
        // More than 2 levels deep
        const routePath = convertToTanStackPath(file.dir);
        const newFileName = `${routePath}.tsx`;

        nested.push({
          original: file,
          suggested: {
            oldPath: file.relativePath,
            newPath: newFileName,
            oldDir: file.dir,
            depth: depth,
            conversionType: "nested-flattening",
          },
        });
      }
    }
  });

  return nested;
}

function generateMigrationPlan(files) {
  const plan = {
    dynamicRoutes: analyzeDynamicRoutes(files),
    layoutPagePairs: analyzeLayoutPagePairs(files),
    nestedRoutes: analyzeNestedRoutes(files),
    summary: {
      totalFiles: files.length,
      needsRestructuring: 0,
    },
  };

  plan.summary.needsRestructuring =
    plan.dynamicRoutes.length +
    plan.layoutPagePairs.length +
    plan.nestedRoutes.length;

  return plan;
}

function printMigrationPlan(plan) {
  console.log("🗂️  TanStack Start File Restructuring Plan");
  console.log(
    "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n",
  );

  console.log("📊 Summary:");
  console.log(`   📁 Total route files analyzed: ${plan.summary.totalFiles}`);
  console.log(
    `   🔄 Files needing restructuring: ${plan.summary.needsRestructuring}`,
  );
  console.log("");

  if (plan.dynamicRoutes.length > 0) {
    console.log("🔗 Dynamic Routes (need renaming):");
    console.log(
      "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━",
    );
    plan.dynamicRoutes.forEach((route) => {
      console.log(`   📂 ${route.suggested.oldPath}`);
      console.log(`   ➜  ${route.suggested.newPath}`);
      console.log("");
    });
  }

  if (plan.layoutPagePairs.length > 0) {
    console.log("🔗 Layout + Page Merges (combine into single file):");
    console.log(
      "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━",
    );
    plan.layoutPagePairs.forEach((pair) => {
      console.log(
        `   📂 ${pair.suggested.oldLayoutPath} + ${pair.suggested.oldPagePath}`,
      );
      console.log(`   ➜  ${pair.suggested.newPath}`);
      console.log("");
    });
  }

  if (plan.nestedRoutes.length > 0) {
    console.log("🔗 Nested Routes (flatten with dot notation):");
    console.log(
      "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━",
    );
    plan.nestedRoutes.forEach((route) => {
      console.log(
        `   📂 ${route.suggested.oldPath} (depth: ${route.suggested.depth})`,
      );
      console.log(`   ➜  ${route.suggested.newPath}`);
      console.log("");
    });
  }

  console.log("💡 Next Steps:");
  console.log(
    "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━",
  );
  console.log("1. Review the suggested file restructuring above");
  console.log("2. Create a backup of your current routes");
  console.log("3. Start with dynamic routes (easiest to migrate)");
  console.log("4. Then merge layout+page pairs");
  console.log("5. Finally flatten deeply nested routes");
  console.log("6. Update imports after each phase");
  console.log("7. Test thoroughly after each change\n");

  if (plan.summary.needsRestructuring === 0) {
    console.log(
      "🎉 Great! Your file structure is already compatible with TanStack Start conventions!",
    );
  } else {
    console.log(
      `📋 Total restructuring tasks: ${plan.summary.needsRestructuring}`,
    );
  }
}

function main() {
  console.log(
    "🔍 Analyzing Next.js file structure for TanStack Start migration...\n",
  );

  const allFiles = getAllRouteFiles(ROUTES_DIR);
  const migrationPlan = generateMigrationPlan(allFiles);

  printMigrationPlan(migrationPlan);
}

main();