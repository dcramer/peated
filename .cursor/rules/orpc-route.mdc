---
description: Instructions when working on OpenAPI routes in Hono.
globs: 
alwaysApply: false
---
# oRPC Route Implementation Conventions

This document defines conventions for implementing and testing API endpoints using the `@orpc/server` framework. It focuses on producing consistent and composable oRPC procedures that align with OpenAPI principles. The guidelines cover how procedures should be structured, named, composed, and validated within a TypeScript codebase.

## File Structure, Imports, and Routing

### Import Rules

Use absolute imports for all modules that are not in the same folder. For example, import middleware, serializers, schemas, or utilities using paths like `@peated/server/orpc`, which maps to `apps/server/src/orpc`.

Avoid relative imports such as `../../../middleware` unless the module is a direct sibling or nearby file. This ensures consistent and readable imports across the codebase.

Example:

```ts
import { requireAuth } from "@peated/server/orpc/middleware";
import { serialize } from "@peated/server/serializers";
```

### Router Structure

All routes are composed using router objects. Each folder should export an `index.ts` that defines a router object, even if it only wraps a single route.

This standardization allows parent routers to compose children consistently, and supports future expansion without breaking the interface.

* Each route corresponds to a semantic file name, not a dynamic parameter.
* Each folder in the path represents a URL segment; dynamic segments (`:id`, `:user`, etc.) are **not** reflected in folder names.
* Route files are named semantically:

  * `list.ts` for collection routes (e.g. `GET /bottles`)
  * `details.ts` for detail routes (e.g. `GET /bottles/:id`)
  * Descriptive names like `login.ts`, `me.ts`, `tastings.ts` for functional or nested routes.
* Each folder with multiple routes includes an `index.ts` file to export the routes with semantic keys.

### Example

For the route `/users/:user/collections/:collection/bottles`:

```bash
routes/
└── users/
    └── collections/
        ├── details.ts           # /users/:user/collections/:collection
        ├── bottles.ts           # /users/:user/collections/:collection/bottles
        └── index.ts             # combines child routes
```

### Root and Lazy Router Composition

A root `index.ts` file should be defined at the top-level `routes/` directory to compose child routers. You may import routers eagerly or use lazy-loading for modularity and startup performance:

#### Eager Composition:

```ts
import auth from "./auth";
import bottles from "./bottles";
import users from "./users";

export default {
  auth,
  bottles,
  users,
};
```

#### Child Router Example

```ts
// routes/users/collections/index.ts
import details from "./details";
import bottles from "./bottles";

export default {
  details,
  bottles,
};
```

## Defining Routes

Each oRPC route is defined using a chained procedure call with a consistent structure. The route declaration must follow the order below:

1. `use` - middleware
2. `route` - HTTP method and path
3. `input` - Zod schema for input
4. `output` - Zod schema for output
5. `handler` - the request handler (must come last)

### Example

```ts
import { os } from "@orpc/server";
import { procedure } from "@peated/server/orpc";

export default procedure
  .route({ method: "GET", path: "/ping" })
  .handler(async function ({ context }) {
    return { ping: "pong" };
  });
```

## HTTP Method Semantics

* **GET**: Read a resource
* **POST**: Create a new resource
* **PUT**: Upsert (create or replace a resource with no primary key)
* **PATCH**: Update (partial update of fields)
* **DELETE**: Remove a resource

For upserts:

* Use PUT on `details.ts` when upserting a resource by ID.
* Use PUT on `list.ts` for batch upserts or composite keys.

Mutations on collections must support batch input.

## Query and Path Parameter Handling

Use `.coerce` for all values passed via query or path, as these arrive as strings. Always define a default where appropriate. If multiple query patterns are possible (e.g., `slug` or `id`), use a union type and disambiguate at runtime.

You may also define enums from constant arrays (e.g. `SORT_OPTIONS`, `FLAVOR_PROFILES`) for filtering or sorting.

All query/path parameters must be treated as strings and coerced using Zod.

```ts
cursor: z.coerce.number().gte(1).default(1),
hasBottles: z.coerce.boolean().default(false),
```

For union types:

```ts
country: z.union([z.string(), z.number()]),
```

Disambiguate types at runtime:

```ts
if (Number.isFinite(+input.country)) {
  // handle numeric ID
}
```

## Error Handling and ORPCError Usage

If an endpoint interacts with the database and may throw constraint or type errors (e.g., duplicate keys, bad filters), wrap the logic in try/catch and rethrow using `ORPCError`. When mapping database constraint violations, include a useful message with any relevant record information.

```ts
if (err.code === "23505" && err.constraint === "user_email_unq") {
  const [existing] = await db.select().from(users).where(...);
  throw new ORPCError("CONFLICT", {
    message: `User already exists (ID=${existing.id}).`,
  });
}
```

Use `ORPCError` for returning errors:

```ts
import { ORPCError } from "@orpc/server";
throw new ORPCError("UNAUTHORIZED", { message: "Invalid Credentials." });
```

* Use OpenAPI-style error codes (`NOT_FOUND`, `UNAUTHORIZED`, etc).
* Always include a complete, properly punctuated message.

## Authentication Middleware

Middleware like `requireAuth` or `requireAdmin` is defined using `.use()`:

```ts
import { requireAuth } from "@peated/server/orpc/middleware";

export default procedure
  .route({ method: "GET", path: "/auth/me", tags: ['Auth'] })
  .use(requireAuth)
  .handler(async function ({ context }) {
    return { whoami: context.user.email };
  });
```

## Testing Routes

Each route should have a corresponding test file named `[routeName].test.ts`. Follow these conventions:

* The `describe` block should use the format `METHOD /path`
* Test valid input, error paths, and edge cases
* Use `fixtures` to create any necessary users or data
* Pass the authenticated user in `context` where applicable

Example:

```ts
describe("POST /auth/login", () => {
  test("valid credentials", async ({ fixtures }) => {
    const user = await fixtures.User({
      email: "foo@example.com",
      password: "example",
    });

    const data = await routerClient.authLogin({
      email: "foo@example.com",
      password: "example",
    });

    expect(data.user.id).toEqual(user.id);
    expect(data.accessToken).toBeDefined();
  });
});
```

### Testing Errors

Use `waitError` and inline snapshots to verify structured errors:

```ts
const err = await waitError(
  routerClient.authLogin({ email: "wrong", password: "bad" })
);
expect(err).toMatchInlineSnapshot();
```

### Assertions

* Assert both the response structure and any DB side-effects
* Prefer checking persisted state rather than echo values
* Avoid testing unrelated fields in the response

## Response Structure and Serialization

## OpenAPI Metadata

Routes can include metadata inside `.route()` to enrich the OpenAPI spec. These fields improve generated API docs and client usability.

```ts
.route({
  method: "POST",
  path: "/auth/login",
  summary: "Authenticate a user",
  description: "Returns a user session token and profile",
  tags: ["Auth"]
})
```

### Cursor-Based Pagination

Paginated responses must follow a consistent structure using cursor-based pagination. The returned object should contain two keys:

* `results`: an array of serialized resources.
* `rel`: an object containing `nextCursor` and `prevCursor` values.

This allows clients to efficiently navigate forward and backward through results.

The `CursorSchema` should be used for typing the `rel` key.

```ts
.output(
  z.object({
    results: z.array(ResourceSchema),
    rel: CursorSchema,
  })
)
```

During implementation:

* Always query one extra record (`limit + 1`) to determine if a next page exists.
* Slice the result to `limit` before serializing.
* Calculate cursors based on the current offset or cursor position.

Example:

```ts
return {
  results: await serialize(
    ResourceSerializer,
    records.slice(0, limit),
    context.user,
  ),
  rel: {
    nextCursor: records.length > limit ? cursor + 1 : null,
    prevCursor: cursor > 1 ? cursor - 1 : null,
  },
};
```

### Single Resource Responses

For single object responses, return a named key for the resource, matching the object type. This improves clarity and structure for clients.

Example:

```ts
.output(z.object({ user: UserSchema }))
.handler(async function ({ context }) {
  return {
    user: serialize(UserSerializer, context.user, context.user),
  };
});
```

* Always prefix returned resources with a semantic key (`user`, `bottle`, `flight`, etc.)
* Use serializers to control which fields are exposed to the user
* All schemas must be defined in `apps/server/src/schemas` using Zod
