---
description: Instructions when working on OpenAPI routes in Hono.
globs: 
alwaysApply: false
---
## Technology

We use the `orpc` framework, which provides our OpenAPI support. All code is written in TypeScript.
The `zod` library is used for schemas.

Imports from the `apps/api` package should always use the `@peated/api` import path, rather
than use relative imports. The only exception to this rule is when you're importing code which is
in the same directory and is not a shared utility.

## Conventions

Routes are located in `apps/server/src/orpc/routes` and are named based on their URL path.

Include only thet relative route location from the version
(e.g. `/auth` vs `/v1/auth`). It will never include the `/v1` prefix.

Here are some examples of file paths:

| Path                    | File Path                 |
| ----------------------- | ------------------------- |
| `/auth/me`              | `auth/me.ts`              |
| `/auth/register`        | `auth/register.ts`        |
| `/bottles`              | `bottles/index.ts`        |
| `/bottles/:id`          | `bottles/$id.ts`          |
| `/bottles/:id/tastings` | `bottles/$id/tastings.ts` |
| `/bottle-aliases`       | `bottle-aliases/index.ts` |

You will also need to define an `router.ts` in each path to create an oRPC router:

```ts
// auth/router.ts
import me from "./me";
import register from "./register";

export { me, register };
```

This router then gets registered in the root router at `apps/server/src/orpc/router.ts`:

```ts
// we use the Router suffix to avoid complexity here
import authRouter from "./routes/auth/router";

export default {
    auth: authRouter,
};
```

Tests should live side-by-side with the routes:

- If the route is at `[...]/auth.ts` the tests should be in `[...]/auth.test.ts`

## Route Definition

Routes are created as an oRPC procedure, using the `@orcp/server` package:

```ts
import { os } from "@orpc/server";
import { procedure } from "..";

export default procedure
  .route({ method: "GET", path: "/ping" })
  .handler(async function ({ context }) {
    return { ping: "pong" };
  });
```

Methods chained on the procedure should be ordered as followed:

1. `use` - any middleware clauses
2. `route` - the openapi route definition (the `openapi` definition)
3. `input` - the input schema (a `zod` schema)
4. `output` - the output schema (a `zod` schema)
5. `handler` - the handler should always be last

## Paths

We follow the standard REST pattern of `/collectionName/:identifierName`, with subcollections where it
makes sense.

- Collections should be plural: /bottles
- Items should be attached to their collections: /bottles/:id

### HTTP Verbs

Use the following patterns for the verb in routes:

- GET: read a resource
- POST: create a new resource
- PUT: upsert a resource (create or update, without a primary key)
- PATCH: update a resource (fields are always optional on updates)
- DELETE: delete a resource

Additionally for UPSERT type behavior:

- If the operation is on a singular primary key, use the dedicated resource details with PUT.
- If the operation is on multiple objects, or its on a composite key, use the collection endpoint with PUT.

When mutation operations are exposed on collections they must always support batch inputs.

### Query and Path Parameters

Input parameters that may come from the path or query string must treat all inputs as strings. Query string
parameters are input parameters from any procedure definition which is `method: "GET"`.

We still want typed parameters, so we use the `coerce` behavior in Zod for this.

Numbers and Booleans are straight forward:

```ts
{
  cursor: z.coerce.number().gte(1).default(1),
  hasBottles: z.coerce.boolean().default(false),
}
```

Union types are a bit more complicated. We often use a union type when we want to allow a numeric ID
in addition to something like a `slug`. To work around this we accept both values in the input:

```ts
{
  country: z.union([z.string(), z.number()]),
}
```

You then need to test the string to determine if its a number:

```ts
if (Number.isFinite(+input.country)) {
}
```

This will not on its own satisfy the type-checker, so you'll need to assign it to a variable or otherwise
type-cast it with `Number()` or `String()`.

### Error Responses

When returning errors from routes, such as an HTTP 401 Unauthorized response, you should use the
`OrpcError` class as control flow.

```ts
import { ORPCError } from "@orpc/server";

throw new ORPCError("UNAUTHORIZED", { message: "Invalid Credentials." });
```

This will be caught by the error handler and converted to the appropriate HTTP response.

Errors should always use the following rules:

- the value of the error should be mapped to an HTTP Status Code (`NOT_FOUND`, `UNAUTHORIZED`, etc)
- the message should be generally provided, and be a sentence (that is, ending with puncutation, proper capitalization, etc).

### Authentication

Authentication can be added to an endpoint view a few middlewares. These are all found in
`apps/server/src/orpc/middleware`. Commonly you will use something like `requireAuth` or
`requireAdmin`. These are defined in the `procedure` call:

```ts
import { os } from "@orpc/server";
import { requireAuth } from "@peated/server/orpc/middleware";
import { procedure } from "..";

export default procedure
  .route({ method: "GET", path: "/auth/me" })
  .use(requireAuth)
  .handler(async function ({ context }) {
    return { whoami: context.user.email };
  });
```

### Response Serialization

Responses should be defined using `.output()` on the procedure, and then serialized using one of
our `Serializer` classes. These are found in `apps/server/src/serializers`.

For example:

```ts
import { os } from "@orpc/server";
import { requireAuth } from "@peated/server/orpc/middleware";
import { UserSchema } from "@peated/server/schemas";
import { serialize } from "@peated/server/serializers";
import { UserSerializer } from "@peated/server/serializers/user";
import { eq } from "drizzle-orm";
import { z } from "zod";
import { procedure } from "..";

export default procedure
  .route({ method: "GET", path: "/auth/me" })
  .use(requireAuth)
  .output(z.object({ user: UserSchema }))
  .handler(async function ({ context }) {
    // serialize(SerializerClass, objectOrArrayOfObjects, currentUserOrNull);
    return {
      user: serialize(UserSerializer, context.user, context.user),
    };
  });
```

All schemas are Zod schemas, and should exist for every core object type. These live in `apps/server/src/schemas`.

For `list`-type responses, we return a standard format that uses the `results` key (as an array of the items), and
the `rel` key which contains our `CursorSchema`.

```ts
import { CursorSchema } from "@peated/server/schemas";

// ...

return {
  results: await serialize(
    CountrySerializer,
    results.slice(0, limit),
    context.user
  ),
  rel: CursorSchema,
};
```

For responses which return an object, we prefix them with the object-type to make nesting of other attributes easier
and to create more uniformity in the types of responses:

```ts
return {
  user: await serializer(UserSerializer, user, context.user);
}
```

## Tests

Tests should be defined in `[routeName].test.ts`. They should use standard patterns that you
can see in other similar route tests.

The description passed to `describe` should ALWAYS be `METHOD /path`, representing the
specific HTTP route.

```ts
import { routerClient } from "../router";

describe("POST /auth/login", () => {
  test("valid credentials", async ({ fixtures }) => {
    const user = await fixtures.User({
      email: "foo@example.com",
      password: "example",
    });

    const data = await routerClient.authLogin({
      email: "foo@example.com",
      password: "example",
    });

    expect(data.user.id).toEqual(user.id);
    expect(data.accessToken).toBeDefined();
  });
});
```

If you need to test against an authenticated user, you can create it via `fixtures`, and pass
it in via `context`:

```ts
import waitError from "@peated/server/lib/test/waitError";
import { routerClient } from "../router";

describe("GET /auth/me", () => {
  test("returns user details for authenticated user", async ({ fixtures }) => {
    const user = await fixtures.User();
    const data = await routerClient.authMe({}, { context: { user } });

    expect(data.user.id).toEqual(user.id);
    expect(data.user.email).toEqual(user.email);
  });
});
```

You should always assert that the relevant database objects have been created as part of the
test, vs only asserting on the response.

- DO check the database object has been updated correctly.
- DO NOT assert on outputs that are unrelated to the inputs.

### Testing Errors

When asserting against errors:

- Use `waitError` to grab the error object.
- Use `toMatchInlineSnapshot` on the value. This makes it easy for us to make changes later.

```ts
import waitError from "@peated/server/lib/test/waitError";
import { routerClient } from "../router";

describe("POST /auth/login", () => {
  test("invalid credentials", async ({ fixtures }) => {
    await fixtures.User({
      email: "foo@example.com",
      password: "example",
    });

    const err = await waitError(
      routerClient.authLogin({
        email: "foo@example.com",
        password: "example2",
      })
    );
    expect(err).toMatchInlineSnapshot();
  });
});
```

### Running Tests

You can run tests with the following command from the package root:

```shell
pnpm --filter ./apps/api test --run [routeName]
```

For example, to run ALL route tests:

```shell
pnpm --filter ./apps/api test --run routes
```

Or to just run the `authRegister` route tests:

```shell
pnpm --filter ./apps/api test --run authRegister
```
