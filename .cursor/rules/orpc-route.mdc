---
description: Instructions when working on OpenAPI routes in Hono.
globs: 
alwaysApply: false
---
# oRPC Route Implementation Conventions

This document defines the conventions for implementing, naming, and testing routes using the `@orpc/server` framework. It is designed to align with OpenAPI principles while maintaining consistency and ergonomic developer experience.

## File Structure and Naming

* Each route corresponds to a semantic file name, not a dynamic parameter.
* Each folder in the path represents a URL segment; dynamic segments (`:id`, `:user`, etc.) are **not** reflected in folder names.
* Route files are named semantically:

  * `list.ts` for collection routes (e.g. `GET /bottles`)
  * `details.ts` for detail routes (e.g. `GET /bottles/:id`)
  * Descriptive names like `login.ts`, `me.ts`, `tastings.ts` for functional or nested routes.
* Each folder with multiple routes includes a `router.ts` to export the routes with semantic keys.
* If a folder contains only a single route file, a `router.ts` file is not required.

### Example

For the route `/users/:user/collections/:collection/bottles`:

```bash
routes/
└── users/
    └── collections/
        ├── details.ts           # /users/:user/collections/:collection
        ├── bottles.ts           # /users/:user/collections/:collection/bottles
        └── router.ts            # combines child routes
```

### Root Router Composition

A root `router.ts` should be defined at the top-level `routes/` directory to compose all sub-routers:

```ts
import auth from "./auth/router";
import bottles from "./bottles/router";
import users from "./users/router";

export default {
  auth,
  bottles,
  users,
};
```

Child `router.ts` files should import semantic route modules from their folder and return an object:

```ts
// routes/users/collections/router.ts
import details from "./details";
import bottles from "./bottles";

export default {
  details,
  bottles,
};
```

## Route Definition Order

Route procedures are defined using method chaining. The correct order is:

1. `use` – middleware
2. `route` – HTTP method and path
3. `input` – Zod schema for input
4. `output` – Zod schema for output
5. `handler` – the request handler (must come last)

### Example

```ts
import { os } from "@orpc/server";
import { procedure } from "..";

export default procedure
  .route({ method: "GET", path: "/ping" })
  .handler(async function ({ context }) {
    return { ping: "pong" };
  });
```

## HTTP Verb Semantics

* **GET**: Read a resource
* **POST**: Create a new resource
* **PUT**: Upsert (create or replace a resource with no primary key)
* **PATCH**: Update (partial update of fields)
* **DELETE**: Remove a resource

For upserts:

* Use PUT on `details.ts` when upserting a resource by ID.
* Use PUT on `list.ts` for batch upserts or composite keys.

Mutations on collections must support batch input.

## Query and Path Parameters

All query/path parameters must be treated as strings and coerced using Zod.

```ts
cursor: z.coerce.number().gte(1).default(1),
hasBottles: z.coerce.boolean().default(false),
```

For union types:

```ts
country: z.union([z.string(), z.number()]),
```

Disambiguate types at runtime:

```ts
if (Number.isFinite(+input.country)) {
  // handle numeric ID
}
```

## Error Responses

Use `ORPCError` for returning errors:

```ts
import { ORPCError } from "@orpc/server";
throw new ORPCError("UNAUTHORIZED", { message: "Invalid Credentials." });
```

* Use OpenAPI-style error codes (`NOT_FOUND`, `UNAUTHORIZED`, etc).
* Always include a complete, properly punctuated message.

## Authentication

Middleware like `requireAuth` or `requireAdmin` is defined using `.use()`:

```ts
import { requireAuth } from "@peated/server/orpc/middleware";

export default procedure
  .route({ method: "GET", path: "/auth/me" })
  .use(requireAuth)
  .handler(async function ({ context }) {
    return { whoami: context.user.email };
  });
```

## Response Serialization

Use `.output()` and a `Serializer` to define and format responses:

```ts
.output(z.object({ user: UserSchema }))
.handler(async function ({ context }) {
  return {
    user: serialize(UserSerializer, context.user, context.user),
  };
});
```

* All response schemas must be defined in `apps/server/src/schemas` using Zod.
* Use the `serialize()` helper and serializer classes for object outputs.
* List responses use `{ results, rel }` format, where `rel` includes `CursorSchema`.

## Tests

Test files must match `[routeName].test.ts` and include a `describe()` call with the format: `METHOD /path`.

### Example

```ts
describe("POST /auth/login", () => {
  test("valid credentials", async ({ fixtures }) => {
    const user = await fixtures.User({
      email: "foo@example.com",
      password: "example",
    });

    const data = await routerClient.authLogin({
      email: "foo@example.com",
      password: "example",
    });

    expect(data.user.id).toEqual(user.id);
  });
});
```

### Testing Errors

Use `waitError()` and `toMatchInlineSnapshot()`:

```ts
const err = await waitError(routerClient.authLogin({ ... }));
expect(err).toMatchInlineSnapshot();
```

## Running Tests

```bash
pnpm --filter ./apps/api test --run [routeName]
```

Examples:

* All routes: `pnpm --filter ./apps/api test --run routes`
* One route: `pnpm --filter ./apps/api test --run authRegister`
